# 基础知识

# 初始化项目

Hardhat 项目是安装了`hardhat`包和`hardhat.config.js`文件的 Node.js 项目。

- 初始化

```bash
yarn init -y
```

- 安装hardhat

```bash
yarn add --dev hardhat
```

运行yarn hardhat创建项目：

![Untitled](%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%206729c8b6340644b6acc7fa94397a698a/Untitled.png)

如果选择`Create an empty hardhat.config.js`，那么hardhat将只创建如下文件：

```jsx
/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: "0.8.9",
};
```

## 项目结构

如果您选择*`Create a JavaScript project`*，一个简单的项目创建向导会问您一些问题。之后，向导将创建一些目录和文件并安装必要的依赖项。这些依赖关系中最重要的是****[Hardhat Toolbox](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-toolbox#hardhat-toolbox)****，一个捆绑了开始使用 Hardhat 所需的所有东西的插件。

初始化的项目结构如下：

```jsx
contracts/
scripts/
test/
hardhat.config.js
```

这些是 Hardhat 项目的默认路径。

- `contracts/`是合约的源文件
- `test/`是你的测试的脚本
- `scripts/`是简单的自动化脚本

如果想用自定义的路径，请查看[路径配置部分](%E9%85%8D%E7%BD%AE%20509445dbc74b443e8af4d3b773694ea7.md).

# 编译合约

要在 Hardhat 项目中编译合约，请使用内置`compile`任务：

```bash
yarn hardhat compile
```

默认情况下，编译后的内容将保存在`artifacts/`目录中，或者您配置的工件路径。可以查看[路径配置部分](%E9%85%8D%E7%BD%AE%20509445dbc74b443e8af4d3b773694ea7.md)，学习如何改变编译后的保存路径。如果该目录不存在，将创建该目录。

初始编译后，Hardhat 将在您下次编译时尽量减少工作量。例如，如果自上次编译以来您没有更改任何文件，则不会编译任何内容：

![Untitled](%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%206729c8b6340644b6acc7fa94397a698a/Untitled%201.png)

## 配置编译器

如果您需要自定义 Solidity 编译器选项，那么您可以通过配置`hardhat.config.js`中的`solidity`字段。 使用此字段的最简单方法是设置编译器版本：

```tsx
module.exports = {
  solidity: "0.8.9",
};
```

我们建议在配置文件中一定要设置编译器版本，以避免在发布新版本的 Solidity 时出现意外行为或编译错误。

<aside>
❗ Hardhat 将自动下载`solc`您设置的版本。如果您使用 HTTP 代理，则可能需要将`HTTP_PROXY`或`HTTPS_PROXY`环境变量设置为代理的 URL。

</aside>

更多配置：

```tsx
module.exports = {
  solidity: {
    version: "0.8.9",
    settings: {
      optimizer: {
        enabled: true,
        runs: 1000,
      },
    },
  },
};
```

如果您的任何合约与您配置的编译器版本不一致，则 Hardhat 将抛出错误。

# 测试合约

编译合约后，下一步需要编写一些测试用例来验证他们是否按照预期工作。

这个教程会介绍推荐的在hardhat中测试合约的方法。它使用[ether.js](https://docs.ethers.io/v5/)连接hardhat网络，用[Mocha](https://mochajs.org/)和[Chai](https://www.chaijs.com/)来测试。他也用了自定义的[Chai matcher](https://hardhat.org/hardhat-chai-matchers)和[hardhat Network Helpers](https://hardhat.org/hardhat-network-helpers)使得编写测试代码更简单。这些工具包都是Hardhat Toolbox插件的一部分，如果你跟着上面的教程在操作，那么你已经安装他们了。

虽然这是我们推荐的测试设置，但 Hardhat 非常灵活：您可以自定义方法或使用其他工具采用完全不同的路径。

## ****初始设置****

项目初始化后，会在看到`/test/Lock.js`文件，这里包含了一些示例测试。这里先忽略它，创建一个`/test/my-tests.js`文件

## 一个简单的测试用例

这里将为`Lock`合约编写测试用例，如果还没有来得及看合约内容，可以先到`/contracts/Lock.sol`查看合约。

在这个测试用例中，我们将部署Lock合约，并且断言`unlockTime`和构造函数传递的`_unlockTime`时间相同：

```tsx
const { expect } = require("chai");
const hre = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Lock", function () {
  it("Should set the right unlockTime", async function () {
    const lockedAmount = 1_000_000_000;
    const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
    const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

    // deploy a lock contract where funds can be withdrawn
    // one year in the future
    const Lock = await hre.ethers.getContractFactory("Lock");
    const lock = await Lock.deploy(unlockTime, { value: lockedAmount });

    // assert that the value is correct
    expect(await lock.unlockTime()).to.equal(unlockTime);
  });
});
```

首先，我们导入需要用的工具包：`expect`用来写断言，`hre`和`hardhat-network-helpers`作用于hardhat网络。然后使用`describe`和`it`方法，这两个方法是全局`[Macha](https://mochajs.org/#getting-started)`方法，用来描述和组合测试用例的。

测试用例其实是it函数回调参数里面的内容。首先定义变量`lockedAmount`（用来表示lock的金额）和`unlockTime`。`time.latest()`表示最后一个被挖出的区块的时间戳。然后部署合约：首先获取`Lock`合约，然后部署它，将unlockTime作为构造函数参数传递进去，并且传递了一个带有交易信息的对象，这个对象是可选的，这里设置`value`字段来发送ETH。

最后我们检查合约返回的`unlockTime`和部署时传入的`unlockTime`是否相等。合约里的所有方法都是异步的，所以我们必须使用`await`关键字来获取值，否则我们将会比较`promise`对象和数字，这样永远都是错误的。

## 测试一个会回滚的函数

在上一个测试中，我们检查了getter方法是否返回的是正确值。getter是一个只读方法，调用的时候并不会支付费用，也没有任何风险。但是其他能改变合约状态的方法，例如合约中的withdraw方法。意味着我们需要满足一些前提条件才能成功调用此函数。如果您查看它的第一行，您会看到一些`require`用于此目的的检查：

```solidity
function withdraw() public {
    ...

    require(block.timestamp >= unlockTime, "You can't withdraw yet");
    require(msg.sender == owner, "You aren't the owner");
		...
}
```

第一个表达式是检查当前时间是否到达了unlockTime，第二个表达式是检查调用者是不是合约拥有者。下面我们来写一个测试用例来测试第一个表达式，继续在`/test/my-tests.js`中添加以下代码：

```tsx
it("Should revert with the right error if called too soon", async function () {
    const lockedAmount = 1_000_000_000;
    const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
    const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

    // deploy a lock contract where funds can be withdrawn
    // one year in the future
    const Lock = await hre.ethers.getContractFactory("Lock");
    const lock = await Lock.deploy(unlockTime, { value: lockedAmount });

    // assert withdraw
    await expect(lock.withdraw()).to.be.revertedWith("You can't withdraw yet");
  });
```

上一个测试用例，我们使用了`.to.equal`，它是`Chai`的一部分，被用来比较两个值。这里我们使用了`.to.be.revertedWith`，断言这个交易会回滚，并且回滚的原因和给定的字符串相等。

请注意，在之前的测试中我们写了`expect(await ...)`但现在我们的写法是`await expect(...)`。在第一种情况下，我们以同步方式比较两个值；内部 await 就在那里等待检索值。在第二种情况下，整个断言是异步的，因为它必须等到交易被挖出来。这意味着`expect`调用返回一个我们必须等待的`promise`。

## 测试unlockTime

在部署合约的时候，我们定义unlockTime为1年，如果我们想编写一个测试用例来检查解锁时间过后会发生什么，我们不能等待1年再去测试。我们可以设置更短的解锁时间，比如5秒，但是这在实际测试中也需要等待一段时间。

解决方案是模拟时间的流逝，我们可以使用`[time.increaseTo](https://hardhat.org/hardhat-network-helpers/docs/reference#increaseto(timestamp))`，它会用给定的时间戳去挖一个新区块：

```tsx
it("Should transfer the funds to the owner", async function () {
    const lockedAmount = 1_000_000_000;
    const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
    const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

    // deploy a lock contract where funds can be withdrawn
    // one year in the future
    const Lock = await hre.ethers.getContractFactory("Lock");
    const lock = await Lock.deploy(unlockTime, { value: lockedAmount });

    await time.increaseTo(unlockTime);

    // this will throw if the transaction reverts
    await lock.withdraw();
  });
```

## 测试不同地址

`withdraw`函数所做的第二项检查是该函数是由合约所有者调用的。默认情况下，部署和函数调用首先完成帐户配置. 如果我们想检查是否只有所有者可以调用某些函数，我们需要使用不同的帐户来验证它是否失败。

`ethers.getSigners()`返回一个包含所有已配置帐户的数组。我们可以用不同的账户调用合约的`.connect`方法调用来检查交易是否会回滚：

```tsx
it("Should revert with the right error if called from another account", async function () {
    const lockedAmount = 1_000_000_000;
    const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
    const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

    // deploy a lock contract where funds can be withdrawn
    // one year in the future
    const Lock = await hre.ethers.getContractFactory("Lock");
    const lock = await Lock.deploy(unlockTime, { value: lockedAmount });
  
    const [owner, otherAccount] = await ethers.getSigners();
  
    // we increase the time of the chain to pass the first check
    await time.increaseTo(unlockTime);
  
    // We use lock.connect() to send a transaction from another account
    await expect(lock.connect(otherAccount).withdraw()).to.be.revertedWith(
      "You aren't the owner"
    );
```

在这里，我们再次调用一个函数并断言它返回正确的原因字符串。不同之处在于我们是使用不同的地址来使用`.connect(anotherAccount)`来调用`withdraw`。

## 统一重复代码

通过上面的例子我们发现，每个测试用例都会写一遍部署合约的代码。在Mocha中，我们可以用`beforeEach`来处理，只需要写一次，也可以在每个测试用例里面单独部署：

```tsx
describe("Lock", function () {
  let lock;
  let unlockTime;
  let lockedAmount = 1_000_000_000;

  beforeEach(async function () {
    const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
    unlockTime = (await helpers.time.latest()) + ONE_YEAR_IN_SECS;

    const Lock = await ethers.getContractFactory("Lock");
    lock = await Lock.deploy(unlockTime, { value: lockedAmount });
  });

  it("some test", async function () {
    // use the deployed contract
  });
});
```

但是使用这种方法有两个问题：

- 如果你需要部署很多合同，你的测试会很慢，因为在beforeEach中每个合同不得不发送很多次交易。
- beforeEach中的共享变量是丑陋且容易出错的。

`loadFixture`可以同时解决上述两个问题。`loadFixture`接收一个*`fixture`*（一个将链设置为某个所需状态的函数）。当第一次执行`loadFixture`时，*`fixture`*被执行。但是loadFixture第二次执行时，不会再次执行 *`fixture`*，而是将网络状态重置为执行 *`fixture`* 之后的状态。这样速度更快，并且它会撤消之前测试所做的任何状态更改。我们来将前面的测试用例修改成以下样子：

```tsx
const { expect } = require("chai");
const hre = require("hardhat");
const {
  time,
  loadFixture,
} = require("@nomicfoundation/hardhat-network-helpers");

describe("Lock", function () {
  async function deployOneYearLockFixture() {
    const lockedAmount = 1_000_000_000;
    const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
    const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

    const Lock = await ethers.getContractFactory("Lock");
    const lock = await Lock.deploy(unlockTime, { value: lockedAmount });

    return { lock, unlockTime, lockedAmount };
  }

  it("Should set the right unlockTime", async function () {
    const { lock, unlockTime } = await loadFixture(deployOneYearLockFixture);

    // assert that the value is correct
    expect(await lock.unlockTime()).to.equal(unlockTime);
  });

  it("Should revert with the right error if called too soon", async function () {
    const { lock } = await loadFixture(deployOneYearLockFixture);

    await expect(lock.withdraw()).to.be.revertedWith("You can't withdraw yet");
  });

  it("Should transfer the funds to the owner", async function () {
    const { lock, unlockTime } = await loadFixture(deployOneYearLockFixture);

    await time.increaseTo(unlockTime);

    // this will throw if the transaction reverts
    await lock.withdraw();
  });

  it("Should revert with the right error if called from another account", async function () {
    const { lock, unlockTime } = await loadFixture(deployOneYearLockFixture);

    const [owner, otherAccount] = await ethers.getSigners();

    // we increase the time of the chain to pass the first check
    await time.increaseTo(unlockTime);

    // We use lock.connect() to send a transaction from another account
    await expect(lock.connect(otherAccount).withdraw()).to.be.revertedWith(
      "You aren't the owner"
    );
  });
});
```

## 其他测试

查看`test/Lock.js`文件了解其他测试用例

## 测试代码覆盖率

只需运行`coverage`任务，您就会得到一份报告：

```tsx
yarn hardhat coverage
```

![Untitled](%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%206729c8b6340644b6acc7fa94397a698a/Untitled%202.png)

## gas-reporter测试gas使用量

根据测试的执行获取使用了多少 gas，有两种方法：

- `REPORT_GAS=true yarn hardhat test`
- 在`hardhat.config.js`文件中增加：

```tsx
...
require("hardhat-gas-reporter");

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  ...
  gasReporter: {
    enabled: true,
  },
	...
};
```

## 并行测试

```tsx
yarn hardhat test --parallel
```

或在`hardhat.config.js`文件中增加：

```tsx
...

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  ...
  mocha: {
    parallel: true,
  },
...
};
```

大多数情况下，串行或并行跑测试用例会产生相同效果，但在某些情况下，并行运行的测试会表现不同：

- 串行模式下所有测试用例共享一个HRE(Hardhat Runtime Environment)，但是并行状态下不是。Mocha使用一组worker来执行测试用例，每个 worker都有自己的HRE实例。这意味着如果一个测试文件部署了合约，那么该部署会存在于当前这个workder所属的测试用例中，而不会存在于其他worker的测试文件中。
- `.only`修改器在并行模式下不起作用。作为替代方案，您可以使用它`--grep`来运行特定测试（`yarn hardhat test test/my-tests.js --grep revert`），它只会查找描述中包含`grep`后面词语的测试用例来执行。
- 由于并行模式使用更多的系统资源，单个测试的持续时间可能会更长，因此某些测试可能会因此开始超时。如果遇到此问题，您可以在 Hardhat 配置的 Mocha 部分或在测试中使用增加测试超时`this.timeout()`
- 执行测试的顺序是不确定的。

还有一些与并行模式相关的其他限制。您可以在 Mocha 的文档中阅读更多关于它们的信息。如果您在使用并行模式时遇到问题，您可以查看他们的并行模式故障排除部分。